/* msg_publisher.cxx

   A publication of data of type msg

   This file is derived from code automatically generated by the rtiddsgen 
   command:

   rtiddsgen -language C++ -example <arch> msg.idl

   Example publication of type msg automatically generated by 
   'rtiddsgen'. To test them follow these steps:

   (1) Compile this file and the example subscription.

   (2) Start the subscription on the same domain used for RTI Data Distribution
       with the command
       objs/<arch>/msg_subscriber <domain_id> <sample_count>
                
   (3) Start the publication on the same domain used for RTI Data Distribution
       with the command
       objs/<arch>/msg_publisher <domain_id> <sample_count>

   (4) [Optional] Specify the list of discovery initial peers and 
       multicast receive addresses via an environment variable or a file 
       (in the current working directory) called NDDS_DISCOVERY_PEERS. 
       
   You can run any number of publishers and subscribers programs, and can 
   add and remove them dynamically from the domain.

                                   
   Example:
        
       To run the example application on domain <domain_id>:
                          
       On Unix: 
       
       objs/<arch>/msg_publisher <domain_id>
       objs/<arch>/msg_subscriber <domain_id> 
                            
       On Windows:
       
       objs\<arch>\msg_publisher <domain_id>  
       objs\<arch>\msg_subscriber <domain_id>    


modification history
------------ -------
* Add code to store keys of authorized participants

* Define listeners for builtin topics, which get called when
  we find a new participant or reader.

* Create disabled participant to ensure our listeners are installed
  before anything is processed

* Install listeners

* Uncommented the code that authorized a subscriber that belonged to an authorized participant

* Changed ih to be an array of 6 ints instead of 4. An instance handle is the size of 6 ints.
*/

#include <stdio.h>
#include <stdlib.h>
#include "ndds/ndds_cpp.h"
#include "msg.h"
#include "msgSupport.h"

class msgListener : public DDSDataWriterListener {
  public:
    virtual void on_liveliness_lost(
        DDSDataWriter* /*writer*/,
        const DDS_LivelinessLostStatus& /*status*/) {
        printf("liveliness lost\n");
    }

    virtual void on_publication_matched(
        DDSDataWriter* /*writer*/,
        const DDS_PublicationMatchedStatus& status) {
        printf("publication_matched, current count = %d\n",
               status.current_count);
    }
};


//// Start changes for Builtin_Topics

// Authorization string.
const char *auth = "password";

/* Set up a linked list of authorized participant keys.  Datareaders associated
   with an authorized participant do not need to supply their own password.
*/
struct Auth_Node {
    DDS_BuiltinTopicKey_t key;
    struct Auth_Node *next;
};

struct Auth_Node *Auth_List = NULL;

void add_auth_participant(const DDS_BuiltinTopicKey_t &participant_key) {
    Auth_Node *cur = Auth_List;
    if (Auth_List == NULL) {
        cur = Auth_List = new Auth_Node();
    } else {
        while(cur->next != NULL)
            cur = cur->next;
        cur->next = new Auth_Node();
        cur = cur->next;
    }

    memcpy(&cur->key, &participant_key, sizeof(cur->key));
    cur->next = NULL;
}

bool is_auth_participant(const DDS_BuiltinTopicKey_t &participant_key) {
    Auth_Node *cur = Auth_List;
    while (cur != NULL) {
        if (memcmp(&cur->key, &participant_key, sizeof(cur->key)) == 0)
            return true;
        cur = cur->next;
    }
    return false;
}

/* The builtin subscriber sets participant_qos.user_data and
   reader_qos.user_data, so we set up listeners for the builtin
   DataReaders to access these fields.
*/

class BuiltinParticipantListener : public DDSDataReaderListener {
public:
    virtual void on_data_available(DDSDataReader *reader);
};

// This gets called when a participant has been discovered
void BuiltinParticipantListener::on_data_available(DDSDataReader *reader)
{
    DDSParticipantBuiltinTopicDataDataReader *builtin_reader =
        (DDSParticipantBuiltinTopicDataDataReader*) reader;
    DDS_ParticipantBuiltinTopicDataSeq data_seq;
    DDS_SampleInfoSeq info_seq;
    DDS_ReturnCode_t retcode;

    char *participant_data;
    
    // We only process newly seen participants
    retcode = builtin_reader->take(data_seq, info_seq, DDS_LENGTH_UNLIMITED, 
                                   DDS_ANY_SAMPLE_STATE, DDS_NEW_VIEW_STATE, 
                                   DDS_ANY_INSTANCE_STATE);

    // This happens when we get announcements from participants we
    // already know about
    if (retcode == DDS_RETCODE_NO_DATA)
        return;

    if (retcode != DDS_RETCODE_OK) {
        printf("***Error: failed to access data from the built-in reader\n");
        return;
    }

    for(int i = 0; i < data_seq.length(); ++i) {
        if (!info_seq[i].valid_data)
            continue;

        participant_data = "nil";
        bool isauth = false;
        // see if there is any participant_data
        if (data_seq[i].user_data.value.length() != 0) {
            // This sequence is guaranteed to be contiguous
            participant_data = (char*)&data_seq[i].user_data.value[0];
            if (strcmp(participant_data, auth) == 0) {
                add_auth_participant(data_seq[i].key);
                isauth = true;
            }
        }

        printf("Built-in Reader: found participant \n\tkey->'%08x %08x %08x'\n\tuser_data->'%s'\n",
               data_seq[i].key.value[0],
               data_seq[i].key.value[1],
               data_seq[i].key.value[2],
               participant_data);        

		int ih[6];
        memcpy(ih, &info_seq[i].instance_handle, sizeof(info_seq[i].instance_handle));
        printf("instance_handle: %08x%08x %08x%08x %08x%08x \n", ih[0], ih[1], ih[2], ih[3], ih[4], ih[5]);

        if (!isauth) {
            printf("Bad authorization, ignoring participant\n");
            DDSDomainParticipant *participant =
                reader->get_subscriber()->get_participant();
            retcode = participant->ignore_participant(info_seq[i].instance_handle);
            if (retcode != DDS_RETCODE_OK) {
                printf("error ignoring participant: %d\n", retcode);
                return;
            }
        }
    }

    builtin_reader->return_loan(data_seq, info_seq);
}
   
class BuiltinSubscriberListener : public DDSDataReaderListener {
public:
    virtual void on_data_available(DDSDataReader* reader);
};

// This gets called when a new subscriber has been discovered
void BuiltinSubscriberListener::on_data_available(DDSDataReader *reader)
{
    DDSSubscriptionBuiltinTopicDataDataReader *builtin_reader = 
        (DDSSubscriptionBuiltinTopicDataDataReader*) reader;
    DDS_SubscriptionBuiltinTopicDataSeq data_seq;
    DDS_SampleInfoSeq info_seq;
    DDS_ReturnCode_t retcode;

    char *reader_data;

    // We only process newly seen subscribers
    retcode = builtin_reader->take(data_seq, info_seq, DDS_LENGTH_UNLIMITED, 
                                   DDS_ANY_SAMPLE_STATE, DDS_NEW_VIEW_STATE, 
                                   DDS_ANY_INSTANCE_STATE);

    if (retcode == DDS_RETCODE_NO_DATA)
        return;

    if (retcode != DDS_RETCODE_OK) {
        printf("***Error: failed to access data from the built-in reader\n");
        return;
    }

    for (int i = 0; i < data_seq.length(); ++i) {
        if (!info_seq[i].valid_data)
            continue;
        
        reader_data = "nil";
        bool isauth = false;
        // See if this is associated with an authorized participant
        if (is_auth_participant(data_seq[i].participant_key))
			isauth = true;
            
        // See if there is any user_data
        if (data_seq[i].user_data.value.length() != 0) {
            reader_data = (char*)&data_seq[i].user_data.value[0];
            if (!isauth && strcmp(reader_data, auth) == 0)
                isauth = true;
        }

        printf("Built-in Reader: found subscriber \n\tparticipant_key->'%08x %08x %08x'\n\tkey->'%08x %08x %08x'\n\tuser_data->'%s'\n",
               data_seq[i].participant_key.value[0],
               data_seq[i].participant_key.value[1],
               data_seq[i].participant_key.value[2],
               data_seq[i].key.value[0],
               data_seq[i].key.value[1],
               data_seq[i].key.value[2],
               reader_data);


        int ih[6];
        memcpy(ih, &info_seq[i].instance_handle, sizeof(info_seq[i].instance_handle));
        printf("instance_handle: %08x%08x %08x%08x %08x%08x \n", ih[0], ih[1], ih[2], ih[3], ih[4], ih[5]);

        // Ignore unauthorized subscribers
        if (!isauth) {
            printf("Bad authorization, ignoring subscription\n");

                   
            // Get the associated participant...
            DDSDomainParticipant *participant =
                reader->get_subscriber()->get_participant();
            
            // Ignore the remote reader
            retcode = participant->ignore_subscription(info_seq[i].instance_handle);
            if (retcode != DDS_RETCODE_OK) {
                printf("error ignoring subscription: %d\n", retcode);
                return;
            }
        }        
    }
	builtin_reader->return_loan(data_seq, info_seq);
}

//// End changes for Builtin_Topics

/* Delete all entities */
static int publisher_shutdown(
    DDSDomainParticipant *participant)
{
    DDS_ReturnCode_t retcode;
    int status = 0;

    if (participant != NULL) {
        retcode = participant->delete_contained_entities();
        if (retcode != DDS_RETCODE_OK) {
            printf("delete_contained_entities error %d\n", retcode);
            status = -1;
        }

        retcode = DDSTheParticipantFactory->delete_participant(participant);
        if (retcode != DDS_RETCODE_OK) {
            printf("delete_participant error %d\n", retcode);
            status = -1;
        }
    }

    /* RTI Data Distribution Service provides finalize_instance() method for
       people who want to release memory used by the participant factory
       singleton. Uncomment the following block of code for clean destruction of
       the participant factory singleton. */
/*
  retcode = DDSDomainParticipantFactory::finalize_instance();
  if (retcode != DDS_RETCODE_OK) {
  printf("finalize_instance error %d\n", retcode);
  status = -1;
  }
*/

    return status;
}

extern "C" int publisher_main(int domainId, int sample_count)
{
    DDSDomainParticipant *participant = NULL;
    DDSPublisher *publisher = NULL;
    DDSTopic *topic = NULL;
    DDSDataWriter *writer = NULL;
    msgDataWriter * msg_writer = NULL;
    msg *instance = NULL;
    DDS_ReturnCode_t retcode;
    DDS_InstanceHandle_t instance_handle = DDS_HANDLE_NIL;
    const char *type_name = NULL;
    int count = 0;  
    struct DDS_Duration_t send_period = {1,0};

    //// Start changes for Builtin_Topics
    /* By default, the participant is enabled upon construction.
       At that time our listeners for the builtin topics have not
       been installed, so we disable the participant until we
       set up the listeners.
    */
    DDS_DomainParticipantFactoryQos factory_qos;
    retcode = DDSTheParticipantFactory->get_qos(factory_qos);
    if (retcode != DDS_RETCODE_OK) {
        printf("Cannot get factory Qos for domain participant\n");
        return -1;
    }

	factory_qos.entity_factory.autoenable_created_entities = DDS_BOOLEAN_FALSE;

    switch(DDSTheParticipantFactory->set_qos(factory_qos)) {
        case DDS_RETCODE_OK:
            break;
        case DDS_RETCODE_IMMUTABLE_POLICY: {    
            printf("Cannot set factory Qos due to IMMUTABLE_POLICY for domain participant\n");
            return -1;
            break;
        }
        case DDS_RETCODE_INCONSISTENT_POLICY: {    
            printf("Cannot set factory Qos due to INCONSISTENT_POLICY for domain participant\n");
            return -1;
            break;
        }
        default: {
            printf("Cannot set factory Qos for unknown reason for domain participant\n");
            return -1;
            break;
        }
    }
    //// End changes for Builtin_Topics

    /* Get default participant QoS to customize */
    DDS_DomainParticipantQos participant_qos;
    retcode = DDSTheParticipantFactory->get_default_participant_qos(participant_qos);
    if (retcode != DDS_RETCODE_OK) {
        printf("get_default_participant_qos error\n");
        return -1;
    }
    
    DDS_StringSeq temp(0);
    participant_qos.discovery.multicast_receive_addresses = temp;

    participant_qos.discovery_config.participant_liveliness_assert_period.sec = 10;
    participant_qos.discovery_config.participant_liveliness_assert_period.nanosec = 0;

    participant_qos.discovery_config.participant_liveliness_lease_duration.sec = 12;
    participant_qos.discovery_config.participant_liveliness_lease_duration.nanosec = 0;

    /* To create participant with default QoS, use DDS_PARTICIPANT_QOS_DEFAULT
       instead of participant_qos */
    participant = DDSTheParticipantFactory->create_participant(
        domainId, participant_qos, 
        NULL /* listener */, DDS_STATUS_MASK_NONE);
    if (participant == NULL) {
        printf("create_participant error\n");
        publisher_shutdown(participant);
        return -1;
    }

    //// Start changes for Builtin_Topics
    // Installing listeners for the builtin topics requires several steps

    // First get the builtin subscriber
    DDSSubscriber *builtin_subscriber = participant->get_builtin_subscriber();
    if (builtin_subscriber == NULL) {
        printf("***Error: failed to create builtin subscriber\n");
        return 0;
    }

    /* Then get builtin subscriber's datareader for participants
       The type name is a bit hairy, but can be read right to left:
       DDSParticipantBuiltinTopicDataDataReader is a 
       DataReader for
       BuiltinTopicData concerning a discovered
       Participant
    */
    DDSParticipantBuiltinTopicDataDataReader *builtin_participant_datareader =
        (DDSParticipantBuiltinTopicDataDataReader*)
        builtin_subscriber->lookup_datareader(DDS_PARTICIPANT_TOPIC_NAME);
    if (builtin_participant_datareader == NULL) {
        printf("***Error: failed to create builtin participant data reader\n");
        return 0;
    }

    // Install our listener
    BuiltinParticipantListener *builtin_participant_listener = new BuiltinParticipantListener();
    builtin_participant_datareader->set_listener(builtin_participant_listener,
                                                 DDS_DATA_AVAILABLE_STATUS);

    // Get builtin subscriber's datareader for subscribers
    DDSSubscriptionBuiltinTopicDataDataReader *builtin_subscription_datareader =
        (DDSSubscriptionBuiltinTopicDataDataReader*)
        builtin_subscriber->lookup_datareader(DDS_SUBSCRIPTION_TOPIC_NAME);
    if (builtin_subscription_datareader == NULL) {
        printf("***Error: failed to create builtin subscription data reader\n");
        return 0;
    }

    // Install our listener
    BuiltinSubscriberListener *builtin_subscriber_listener = new BuiltinSubscriberListener();
    builtin_subscription_datareader->set_listener(builtin_subscriber_listener,
                                                  DDS_DATA_AVAILABLE_STATUS);

    // Done!  All the listeners are installed, so we can enable the participant now.
    if (participant->enable() != DDS_RETCODE_OK) {
        printf("***Error: Failed to Enable Participant\n");
        return 0;
    }
    //// End changes for Builtin_Topics
    
    /* To customize publisher QoS, use
       participant->get_default_publisher_qos() */
    publisher = participant->create_publisher(
        DDS_PUBLISHER_QOS_DEFAULT, NULL /* listener */, DDS_STATUS_MASK_NONE);
    if (publisher == NULL) {
        printf("create_participant error\n");
        publisher_shutdown(participant);
        return -1;
    }

    /* Register type before creating topic */
    type_name = msgTypeSupport::get_type_name();
    retcode = msgTypeSupport::register_type(
        participant, type_name);
    if (retcode != DDS_RETCODE_OK) {
        printf("register_type error %d\n", retcode);
        publisher_shutdown(participant);
        return -1;
    }

    /* To customize topic QoS, use
       participant->get_default_topic_qos() */
    topic = participant->create_topic(
        "Example msg",
        type_name, DDS_TOPIC_QOS_DEFAULT, NULL /* listener */,
        DDS_STATUS_MASK_NONE);
    if (topic == NULL) {
        printf("create_topic error\n");
        publisher_shutdown(participant);
        return -1;
    }

    /* Get default datawriter QoS to customize */
    DDS_DataWriterQos datawriter_qos;
    retcode = publisher->get_default_datawriter_qos(datawriter_qos);
    if (retcode != DDS_RETCODE_OK) {
        printf("get_default_datawriter_qos error\n");
        return -1;
    }

    datawriter_qos.liveliness.lease_duration.sec = 1;
    datawriter_qos.liveliness.lease_duration.nanosec = 0;


    msgListener *writer_listener = new msgListener();
    /* To create datawriter with default QoS, use DDS_DATAWRITER_QOS_DEFAULT
       instead of datawriter_qos */
    writer = publisher->create_datawriter(
        topic, datawriter_qos, writer_listener,
        DDS_STATUS_MASK_ALL);


//    writer = publisher->create_datawriter(
//        topic, datawriter_qos, NULL /* listener */,
//        DDS_STATUS_MASK_NONE);

    if (writer == NULL) {
        printf("create_datawriter error\n");
        publisher_shutdown(participant);
        return -1;
    }
    msg_writer = msgDataWriter::narrow(writer);
    if (msg_writer == NULL) {
        printf("DataWriter narrow error\n");
        publisher_shutdown(participant);
        return -1;
    }

    /* Create data sample for writing */
    instance = msgTypeSupport::create_data();
    if (instance == NULL) {
        printf("msgTypeSupport::create_data error\n");
        publisher_shutdown(participant);
        return -1;
    }

    /* For data type that has key, if the same instance is going to be
       written multiple times, initialize the key here
       and register the keyed instance prior to writing */
/*
  instance_handle = msg_writer->register_instance(*instance);
*/

    /* Main loop */
    for (count=0; (sample_count == 0) || (count < sample_count); ++count) {
        NDDSUtility::sleep(send_period);

        printf("Writing msg, count %d\n", count);

        /* Modify the data to be sent here */
        instance->x = count;

        retcode = msg_writer->write(*instance, instance_handle);
        if (retcode != DDS_RETCODE_OK) {
            printf("write error %d\n", retcode);
        }
    }

/*
  retcode = msg_writer->unregister_instance(
  *instance, instance_handle);
  if (retcode != DDS_RETCODE_OK) {
  printf("unregister instance error %d\n", retcode);
  }
*/

    /* Delete data sample */
    retcode = msgTypeSupport::delete_data(instance);
    if (retcode != DDS_RETCODE_OK) {
        printf("msgTypeSupport::delete_data error %d\n", retcode);
    }

    /* Delete all entities */
    return publisher_shutdown(participant);
}

#if defined(RTI_WINCE)
int wmain(int argc, wchar_t** argv)
{
    int domainId = 0;
    int sample_count = 0; /* infinite loop */ 
    
    if (argc >= 2) {
        domainId = _wtoi(argv[1]);
    }
    if (argc >= 3) {
        sample_count = _wtoi(argv[2]);
    }

     /* Uncomment this to turn on additional logging
    NDDSConfigLogger::get_instance()->
        set_verbosity_by_category(NDDS_CONFIG_LOG_CATEGORY_API, 
                                  NDDS_CONFIG_LOG_VERBOSITY_STATUS_ALL);
    */
    
    return publisher_main(domainId, sample_count);
}
 
#elif !(defined(RTI_VXWORKS) && !defined(__RTP__)) && !defined(RTI_PSOS)
int main(int argc, char *argv[])
{
    int domainId = 0;
    int sample_count = 0; /* infinite loop */

    if (argc >= 2) {
        domainId = atoi(argv[1]);
    }
    if (argc >= 3) {
        sample_count = atoi(argv[2]);
    }

    /* Uncomment this to turn on additional logging
    NDDSConfigLogger::get_instance()->
        set_verbosity_by_category(NDDS_CONFIG_LOG_CATEGORY_API, 
                                  NDDS_CONFIG_LOG_VERBOSITY_STATUS_ALL);
    */
    
    return publisher_main(domainId, sample_count);
}
#endif
