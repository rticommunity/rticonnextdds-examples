## Example Description

This example shows how to implement a custom *RTI Recording Service* Storage 
plug-in, build it into a shared library and load it with *RTI Recording Service*,
 *RTI Replay Service* or *RTI Converter*.

In this concrete example, we show how a simple storage plug-in written in C++. 
The example is composed of two parts: the writing side (that can be plugged into 
Recorder or Converter) and the reading side (that can be plugged into Replay or 
Converter - although only a Replay configuration file is supplied).

The example works with one single type called `HelloMsg`. The IDL for the type is
supplied. Any other topics or types won't be recorded or replayed. The purpose
of this example is to show how the *Recorder* and *Replay* APIs in C++ can be 
used to plug-in custom storage needs. In this simple example, Recorder will 
store the discovered samples in a file called Cpp_PluggableStorage.dat and a 
companion file called Cpp_PluggableStorage.dat.info, by using the storage 
plug-in. The samples are stored in a textual format. These samples are later 
retrieved by Replay by using the reading plug-in.

The code in this directory provides the following components:

- `FileStorageWriter` implements the writer API that is loaded by 
   *RTI Recorder*. It is responsible for writing the received data samples to 
   file.
- `pluggable_storage_example.xml` file: defines a *Recorder* configuration 
   that loads the shared library resulting from building this example.
- `FileStorageReader` implements the reader API that is loaded by *RTI 
   Replay* or *RTI Converter*. This component is responsible for reading data 
   samples from the file.
- `pluggable_replay_example.xml` file: defines a *Replay* configuration that
   loads the shared library resulting from building this example.
- `HelloMsg.idl`: this IDL file contains a type definition. For example 
   purposes, the storage writer and reader plugins only record and replay this 
   type.
- `HelloMsg_publisher.cxx` and `HelloMsg_subscriber.cxx`: these files use 
   the code for the `HelloMsg` defined in the IDL file above generated by using 
   *RTI DDS Code Generator* in the build process, and publish or subscribe 
   samples of this type.

For more details on how to implement custom plugins, please refer to the 
*RTI Recording Service API* documentation.

## Building the C example

In order to build this example, you need to provide the following variables to
`CMake`:

- `CONNEXTDDS_DIR`
- `CONNEXTDDS_ARCH`

Build the example code by running the following command:

```bash
mkdir build
cd build
cmake -DCONNEXTDDS_DIR=<connext dir> -DCONNEXTDDS_ARCH=<connext architecture> ..
cmake --build .
```

**Cross-compilation**. 
When you need to cross-compile the example, the above
command will not work, the assigned compiler won't be the cross-compiler and
errors may happen when linking against the cross-compiled Connext binaries.
To fix this, you have to create a file with the architecture name and call 
CMake with a specific flag called ``-DCMAKE_TOOLCHAIN_FILE``.
An example of the file to create with the toolchain settings (e.g. for an 
ARM architectures):

```cmake
set(CMAKE_SYSTEM_NAME Linux)
set(toolchain_path "<path to>/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian")
set(CMAKE_C_COMPILER "${toolchain_path}/bin/arm-linux-gnueabihf-gcc")
set(CMAKE_CXX_COMPILER "${toolchain_path}/bin/arm-linux-gnueabihf-g++")
```

Then you can call CMake like this:

```bash
cmake -DCONNEXTDDS_DIR=<connext dir> -DCMAKE_TOOLCHAIN_FILE=<toolchain file created above> 
        -DCONNEXTDDS_ARCH=<connext architecture> ..
```

## Running the C++ example (Recorder storage writer)

First of all, you need to make sure that the `FileStorageWriter` shared 
library is in the library path.  On OS X, you must use the variable 
`RTI_LD_LIBRARY_PATH` instead of the `DYLD_LIBRARY_PATH`.

Run the `HelloMsg` publisher application:

```bash
cd build
HelloMsg_publisher <your domain ID>
```

To run the example, you just need to run the following command from the `build`
folder (where the storage writer plugin shared library has been created).

```bash
cd build
<connext dir>/bin/rtirecordingservice -cfgFile pluggable_storage_example.xml -cfgName CppFileWriterExample -domainIdBase <your domain ID>
```

After running this command, you will see the following output:

```bash
RTI Recording Service (Recorder) 6.0.0 starting...
RTI Recording Service started
```

*Recorder* will create two files, `C_PluggableStorage.dat` and 
`C_PluggableStorage.dat.info`. The `HelloMsg` recorded samples are in the 
*.dat* file. The *.dat.info* file contains information about when the service 
started and finished.

## Running the C example (Replay storage reader)

For *Replay* to have some data to replay, we assume that you have run the 
storage writer example and recorded some data. We also assume that you correctly 
set up the environment to find the `FileStorageReader` library, located in 
the same place as the `FileStorageWriter` one.

If you haven't done it yet, stop the `HelloMsg` publisher application so it 
doesn't interfere.

Now run the `HelloMsg` subscriber application like this:

```bash
cd build
HelloMsg_subscriber <your domain ID>
```

To run the example, you just need to run the following command from the `build`
folder (where the storage reader plugin shared library has been created).

```bash
cd build
<connext dir>/bin/rtireplayservice -cfgFile pluggable_replay_example.xml -cfgName C_ReaderExample -domainIdBase <your domain ID>
```

You should see the samples in the file being published and received by the 
subscribing application. *Note*: If you started Recording Service before 
starting the publisher aplicationp, it may look like Replay is taking a long 
time to start. This happens because the start time of the recording (written in 
the `C_PluggableStorage.dat.info` file) will be much earlier than the first 
recorded sample. For this example, we recommend that you run the publisher 
before you run *Recorder*, so the start time and the time of the first sample 
will be similar. 