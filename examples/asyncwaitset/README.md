# Example Code: Asynchronous WaitSet

## Concept

*The Asynchronous WaitSet (AsyncWaitSet)* is a specialization of the WaitSet
that performs the wait asynchronously using *one or more separate threads of
execution*. Additionally, the *AsyncWaitSet* dispatches the attached and active 
conditions upon wakeup. 

The *AsyncWaitSet* facilitates multi-threaded event processing. Your application
can easily process the statuses generated by the domain entities and even
combine them with application-specific events by means of the *GuardCondition*.

To learn more about the *AsyncWaitSet*, refer to the Connext DDS API 
online documentation. (Eg. [AsyncWaitSet in Modern C++ API]()).


## Example Description

This example shows how to use the *AsyncWaitSet* to process *Connext DDS* and
application-triggered events. There are two applications supplied in this
example: Publisher and Subscriber applications.

The interaction between them is simple. The Publisher sends samples (type is 
defined in aws.idl) and the subscriber reads the receive samples and print their 
content in the standard output.

Both applications use an *AsyncWaitSet* to send and receive data accordingly.

### Publisher

The publisher application shows how to use an *AsyncWaitSet* to send data 
asynchronously in a single separate thread. The application controls when to
send samples by means of a *GuardCondition*.

The publisher sends `aws` samples **periodically**, increasing the  member 
`count` in one unit for each sample sent. The samples are sent in the context of 
a single-threaded *AsyncWaitSet*, to which the application attaches a 
*GuardCondition* to drive the publication rate.

The application's main thread periodically triggers the *GuardCondition* so the 
*AsyncWaitSet* can dispatch it upon wakeup. The application installs a 
*condition handler* on the *GuardCondition* that simply writes the sample on a 
*DataWriter*.


### Subscriber

The subscriber applications shows how to use an *AsyncWaitSet* to process
received samples using multiple-threads. The application process the data
reception by means of the *StatusCondition* of a *DataReader*.

The subscriber simply reads the receive sample as they are received. The 
application uses the *StatusCondition* of the *DataReader* to enable the 
`DATA_AVAILABLE` status and attach it to a multi-threaded *AsyncWaitSet*.

On new data available, the *StatusCondition* triggers and the *AsyncWaitSet*
will use any of its available thread to dispatch the condition. The application 
installs a  *condition handler* on the *StatusCondition* that simply reads
the data from the *DataReader* and prints its content.

To illustrate the concurrency of an *AsyncWaitSet*, the *StatusCondition* 
andler sleeps a random amount of time after the read operation. This is 
purposely intended to emulate long processing time and keep the *AsyncWaitSet* 
dispatching thread busy. Additionally, right before sleeping the handler
also ndicates that the condition can be dispatched again through the 
`AsyncWaitSet::unblock_condition()` operation. Then, if more data arrives
and only if there any idle threads available, the *AsyncWaitSet* will use them 
to dispatch the *StatusCondition* again.



