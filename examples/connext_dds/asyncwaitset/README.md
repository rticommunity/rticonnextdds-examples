# Example Code: Asynchronous WaitSet

## Concept

*The Asynchronous WaitSet (AsyncWaitSet)* is a specialization of the WaitSet
that performs the wait asynchronously using *one or more separate threads of
execution*. Additionally, the *AsyncWaitSet* dispatches the attached and active
conditions upon wakeup.

The *AsyncWaitSet* facilitates multi-threaded event processing. Your application
can easily process the statuses generated by the domain entities and even
combine them with application-specific events by means of *GuardCondition*.

To learn more about the *AsyncWaitSet*, refer to the Connext DDS API online
documentation. (Eg. [AsyncWaitSet in Modern C++
API](https://community.rti.com/static/documentation/connext-dds/current/doc/api/connext_dds/api_cpp2/group__DDSAsyncWaitSetModule.html)).

## Example Description

This example shows how to use the *AsyncWaitSet* to process *Connext DDS* and
application-specific events. There are two applications supplied in this
example: Publisher and Subscriber applications.

The interaction between them is basic. The Publisher sends samples (whose type
is defined in AwsExample.idl) and the Subscriber reads the received samples and
print their content in the standard output.

Both publisher and subscriber applications use an *AsyncWaitSet* to send and
receive data respectively.

### Publisher

The publisher application shows how to use an *AsyncWaitSet* to send data
asynchronously in a single separate thread. The application controls when to
send samples by means of a *GuardCondition*.

The publisher sends `AwsExample` samples **periodically**, increasing the member
`number` in one unit for each sample sent. The samples are sent in the context
of a single-threaded *AsyncWaitSet*, to which the application attaches the
*GuardCondition* to drive the publication rate.

The application's main thread periodically triggers the *GuardCondition* so the
*AsyncWaitSet* can dispatch it upon wakeup. The application installs a
*condition handler* on the *GuardCondition* that simply writes a sample on the
*DataWriter*.

### Subscriber

The subscriber application shows how to use an *AsyncWaitSet* to process
received samples using multiple-threads. The application processes the sample
reception by means of the *StatusCondition* of a *DataReader*.

The subscriber simply reads samples as they are received. The application uses
the *StatusCondition* of the *DataReader* to enable the `DATA_AVAILABLE` status
and attach it to a multi-threaded *AsyncWaitSet*.

On new data available, the *StatusCondition* triggers and the *AsyncWaitSet*
will wake up and use any of its available thread to dispatch the condition. The
application installs a  *condition handler* on the *StatusCondition* that simply
reads the samples from the *DataReader* and prints their content.

To illustrate the concurrency of an *AsyncWaitSet*, the *StatusCondition*
handler sleeps a random period of time after the read operation. This is
purposely intended to emulate long processing time and keep the *AsyncWaitSet*'s
dispatching thread busy.

Additionally, the example also shows how a condition can be dispatched
concurrently. The *StatusCondition* handler, right before the aforementioned
sleep operation, calls `AsyncWaitSet::unblock_condition()` to indicate that the
condition can be dispatched again if necessary. Then, if more samples arrive,
the *AsyncWaitSet* will use any available thread to dispatch the
*StatusCondition* again, causing a concurrent dispatch.
