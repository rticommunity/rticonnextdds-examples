/*******************************************************************************
 (c) 2005-2014 Copyright, Real-Time Innovations, Inc.  All rights reserved.
 RTI grants Licensee a license to use, modify, compile, and create derivative
 works of the Software.  Licensee has the right to distribute object form only
 for use with RTI products.  The Software is provided "as is", with no warranty
 of any type, including any warranty for fitness for any purpose. RTI is under
 no obligation to maintain or support the Software.  RTI shall not be liable for
 any incidental or consequential damages arising out of the use or inability to
 use the software.
 ******************************************************************************/

/* msgPublisher.java

   A publication of data of type msg

   This file is derived from code automatically generated by the rtiddsgen
   command:

   rtiddsgen -language java -example <arch> .idl

   Example publication of type msg automatically generated by
   'rtiddsgen' To test them follow these steps:

   (1) Compile this file and the example subscription.

   (2) Start the subscription on the same domain used for RTI Data Distribution
       Service with the command
       java msgSubscriber <domain_id> <sample_count>

   (3) Start the publication on the same domain used for RTI Data Distribution
       Service with the command
       java msgPublisher <domain_id> <sample_count>

   (4) [Optional] Specify the list of discovery initial peers and
       multicast receive addresses via an environment variable or a file
       (in the current working directory) called NDDS_DISCOVERY_PEERS.

   You can run any number of publishers and subscribers programs, and can
   add and remove them dynamically from the domain.

   Example:

       To run the example application on domain <domain_id>:

       Ensure that $(NDDSHOME)/lib/<arch> is on the dynamic library path for
       Java.

        On Unix:
             add $(NDDSHOME)/lib/<arch> to the 'LD_LIBRARY_PATH' environment
             variable

        On Windows:
             add %NDDSHOME%\lib\<arch> to the 'Path' environment variable


       Run the Java applications:

        java -Djava.ext.dirs=$NDDSHOME/class msgPublisher <domain_id>

        java -Djava.ext.dirs=$NDDSHOME/class msgSubscriber <domain_id>



modification history
------------ -------
*/

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Arrays;
import java.util.LinkedList;

import com.rti.dds.domain.*;
import com.rti.dds.domain.builtin.*;
import com.rti.dds.infrastructure.*;
import com.rti.dds.publication.*;
import com.rti.dds.subscription.*;
import com.rti.dds.subscription.builtin.*;
import com.rti.dds.topic.*;
import com.rti.ndds.config.*;

// ===========================================================================

public class msgPublisher {

//// Start changes for Builtin_Topics

    // -----------------------------------------------------------------------
    // Public Members
    // -----------------------------------------------------------------------

    // Authorization string.
    public static String auth = "password";

    /* The builtin subscriber sets participant_qos.user_data and
       reader_qos.user_data, so we set up listeners for the builtin
       DataReaders to access these fields.
    */
    public static class BuiltinParticipantListener extends DataReaderAdapter {
        ParticipantBuiltinTopicDataSeq _dataSeq =
                new ParticipantBuiltinTopicDataSeq();
        SampleInfoSeq _infoSeq = new SampleInfoSeq();

        // This gets called when a participant has been discovered
        public void on_data_available(DataReader reader) {
            ParticipantBuiltinTopicDataDataReader builtin_reader =
                (ParticipantBuiltinTopicDataDataReader)reader;
            String participant_data;
            ParticipantBuiltinTopicData cur_participant_builtin_topic_data;

            try {

                // We only process newly seen participants
                builtin_reader.take(
                    _dataSeq, _infoSeq,
                    ResourceLimitsQosPolicy.LENGTH_UNLIMITED,
                    SampleStateKind.ANY_SAMPLE_STATE,
                    ViewStateKind.NEW_VIEW_STATE,
                    InstanceStateKind.ANY_INSTANCE_STATE);

                for(int i = 0; i < _dataSeq.size(); ++i) {
                    SampleInfo info = (SampleInfo)_infoSeq.get(i);

                    if (info.valid_data) {
                        participant_data = "nil";
                        boolean is_auth = false;
                        cur_participant_builtin_topic_data =
                                (ParticipantBuiltinTopicData)_dataSeq.get(i);

                        // see if there is any participant_data
                        if (cur_participant_builtin_topic_data.
                                user_data.value.size() > 0) {

                            // This sequence is guaranteed to be contiguous
                            participant_data =
                                    new String(
                                            cur_participant_builtin_topic_data.
                                            user_data.value.toArrayByte(null));
                            is_auth = participant_data.equals(auth);
                        }

                        System.out.println("Builtin Reader: found participant");
                        System.out.println("\tkey->'" + Arrays.toString(
                                cur_participant_builtin_topic_data.key.value) +
                                "'\n\tuser_data->'" + participant_data + "'");
                        System.out.println("instance_handle: " +
                                info.instance_handle);

                        if (!is_auth) {
                            System.out.println(
                                    "Bad authorization, ignoring participant");
                            DomainParticipant participant =
                                    reader.get_subscriber().get_participant();
                            participant.ignore_participant(
                                    info.instance_handle);
                        }
                    }
                }

            } catch (RETCODE_NO_DATA noData) {
                // No data to process
                // This happens when we get announcements from participants we
                // already know about
                return;
            } finally {
                builtin_reader.return_loan(_dataSeq, _infoSeq);
            }
        }
    }

    public static class BuiltinSubscriberListener extends DataReaderAdapter {
        SubscriptionBuiltinTopicDataSeq _dataSeq =
                new SubscriptionBuiltinTopicDataSeq();
        SampleInfoSeq _infoSeq = new SampleInfoSeq();

        // This gets called when a new subscriber has been discovered
        public void on_data_available(DataReader reader) {
            SubscriptionBuiltinTopicDataDataReader builtin_reader =
                (SubscriptionBuiltinTopicDataDataReader)reader;
            SubscriptionBuiltinTopicData cur_subscription_builtin_topic_data;

            try {

                // We only process newly seen subscribers
                builtin_reader.take(
                    _dataSeq, _infoSeq,
                    ResourceLimitsQosPolicy.LENGTH_UNLIMITED,
                    SampleStateKind.ANY_SAMPLE_STATE,
                    ViewStateKind.NEW_VIEW_STATE,
                    InstanceStateKind.ANY_INSTANCE_STATE);

                for(int i = 0; i < _dataSeq.size(); ++i) {
                    SampleInfo info = (SampleInfo)_infoSeq.get(i);

                    if (info.valid_data) {
                        cur_subscription_builtin_topic_data =
                                (SubscriptionBuiltinTopicData)_dataSeq.get(i);


                        System.out.println("Built-in Reader: found subscriber");
                        System.out.println("\tparticipant_key->'"
                                + Arrays.toString(
                                        cur_subscription_builtin_topic_data.
                                        participant_key.value) + "'\n\tkey->'"
                                + Arrays.toString(
                                        cur_subscription_builtin_topic_data.
                                        key.value)
                                + "\n");

                        System.out.println("instance_handle: " +
                                info.instance_handle);
                    }
                }

            } catch (RETCODE_NO_DATA noData) {
                // No data to process
                return;
            } finally {
                builtin_reader.return_loan(_dataSeq, _infoSeq);
            }
        }
    }

//// End changes for Builtin_Topics

    public static void main(String[] args) {
        // --- Get domain ID --- //
        int domainId = 0;
        if (args.length >= 1) {
            domainId = Integer.valueOf(args[0]).intValue();
        }

        // -- Get max loop count; 0 means infinite loop --- //
        int sampleCount = 0;
        if (args.length >= 2) {
            sampleCount = Integer.valueOf(args[1]).intValue();
        }

        /* Uncomment this to turn on additional logging
        Logger.get_instance().set_verbosity_by_category(
            LogCategory.NDDS_CONFIG_LOG_CATEGORY_API,
            LogVerbosity.NDDS_CONFIG_LOG_VERBOSITY_STATUS_ALL);
        */

        // --- Run --- //
        publisherMain(domainId, sampleCount);
    }

    // -----------------------------------------------------------------------
    // Private Methods
    // -----------------------------------------------------------------------

    // --- Constructors: -----------------------------------------------------

    private msgPublisher() {
        super();
    }


    // -----------------------------------------------------------------------

    private static void publisherMain(int domainId, int sampleCount) {

        DomainParticipant participant = null;
        Publisher publisher = null;
        Topic topic = null;
        msgDataWriter writer = null;

        try {

            //// Start changes for Builtin_Topics
            /* If you want to change the Factory's QoS programmatically rather
             * than using the XML file, you will need to add the following lines
             * to your code and comment out the participant call above.
             */

            /* By default, the participant is enabled upon construction.
             * At that time our listeners for the builtin topics have not
             * been installed, so we disable the participant until we
             * set up the listeners.
             */
/*
            DomainParticipantFactoryQos factoryQos =
                    new DomainParticipantFactoryQos();
            DomainParticipantFactory.TheParticipantFactory.get_qos(factoryQos);
            factoryQos.entity_factory.autoenable_created_entities = false;
            DomainParticipantFactory.TheParticipantFactory.set_qos(factoryQos);
*/
            // --- Create participant --- //

            // If you want to change the Participant's QoS programmatically
            // rather than using the XML file, you will need to uncomment the
            // following lines and replace in create_participant the argument
            // DomainParticipantFactory.PARTICIPANT_QOS_DEFAULT with
            // participantQos
            //DomainParticipantQos participantQos = new DomainParticipantQos();
            //DomainParticipantFactory.TheParticipantFactory
            //        .get_default_participant_qos(participantQos);
            //participantQos.resource_limits.participant_user_data_max_length = 1024;

            /* To customize participant QoS, use
               the configuration file USER_QOS_PROFILES.xml */
            participant = DomainParticipantFactory.TheParticipantFactory.
                create_participant(
                    domainId, DomainParticipantFactory.PARTICIPANT_QOS_DEFAULT,
                    null /* listener */, StatusKind.STATUS_MASK_NONE);
            if (participant == null) {
                System.err.println("create_participant error\n");
                return;
            }

            /* Installing listeners for the builtin topics requires several
             * steps
             */

            // First get the builtin subscriber
            Subscriber builtin_subscriber =
                    participant.get_builtin_subscriber();
            if (builtin_subscriber == null) {
                System.err.println(
                        "***Error: failed to create builtin subscriber\n");
                return;
            }

            /* Then get builtin subscriber's datareader for participants
               The type name is a bit hairy, but can be read right to left:
               DDSParticipantBuiltinTopicDataDataReader is a
               DataReader for BuiltinTopicData concerning a discovered
               Participant
            */
            ParticipantBuiltinTopicDataDataReader
                builtin_participant_datareader =
                    (ParticipantBuiltinTopicDataDataReader)
                        builtin_subscriber.lookup_datareader(
                                ParticipantBuiltinTopicDataTypeSupport.
                                PARTICIPANT_TOPIC_NAME);
            if (builtin_participant_datareader == null) {
                System.err.println(
                        "***Error: failed to create builtin participant data"
                        + " reader\n");
                return;
            }

            // Install our listener
            BuiltinParticipantListener builtin_participant_listener =
                    new BuiltinParticipantListener();
            builtin_participant_datareader.set_listener(
                    builtin_participant_listener,
                    StatusKind.DATA_AVAILABLE_STATUS);

            // Get builtin subscriber's datareader for subscribers
            SubscriptionBuiltinTopicDataDataReader
                builtin_subscription_datareader =
                    (SubscriptionBuiltinTopicDataDataReader)
                        builtin_subscriber.lookup_datareader(
                                SubscriptionBuiltinTopicDataTypeSupport.
                                SUBSCRIPTION_TOPIC_NAME);
            if (builtin_subscription_datareader == null) {
                System.err.println("***Error: failed to create builtin "
                        + "subscription data reader\n");
                return;
            }

            // Install our listener
            BuiltinSubscriberListener builtin_subscriber_listener =
                    new BuiltinSubscriberListener();
            builtin_subscription_datareader.set_listener(
                    builtin_subscriber_listener,
                    StatusKind.DATA_AVAILABLE_STATUS);

            /* Done!  All the listeners are installed, so we can enable the
             * participant now.
             */
            participant.enable();

            //// End changes for Builtin_Topics

            // --- Create publisher --- //

            /* To customize publisher QoS, use
               the configuration file USER_QOS_PROFILES.xml */

            publisher = participant.create_publisher(
                DomainParticipant.PUBLISHER_QOS_DEFAULT, null /* listener */,
                StatusKind.STATUS_MASK_NONE);
            if (publisher == null) {
                System.err.println("create_publisher error\n");
                return;
            }


            // --- Create topic --- //

            /* Register the type before creating the topic */
            String typeName = msgTypeSupport.get_type_name();
            msgTypeSupport.register_type(participant, typeName);

            /* To customize topic QoS, use
               the configuration file USER_QOS_PROFILES.xml */

            topic = participant.create_topic(
                "Example msg",
                typeName, DomainParticipant.TOPIC_QOS_DEFAULT,
                null /* listener */, StatusKind.STATUS_MASK_NONE);
            if (topic == null) {
                System.err.println("create_topic error\n");
                return;
            }

            // --- Create writer --- //

            /* To customize publisher QoS, use
               the configuration file USER_QOS_PROFILES.xml */

            writer = (msgDataWriter)
                publisher.create_datawriter(
                    topic, Publisher.DATAWRITER_QOS_DEFAULT,
                    null, StatusKind.STATUS_MASK_NONE);

            if (writer == null) {
                System.err.println("create_datawriter error\n");
                return;
            }

            // --- Write --- //

            /* Create data sample for writing */
            msg instance = new msg();

            InstanceHandle_t instance_handle = InstanceHandle_t.HANDLE_NIL;
            /* For a data type that has a key, if the same instance is going
             * to be written multiple times, initialize the key here
             * and register the keyed instance prior to writing
             */
            //instance_handle = writer.register_instance(instance);

            //// Changes for Builtin_Topics
            final long sendPeriodMillis = 1000; // 1 second

            for (short count = 0;
                 (sampleCount == 0) || (count < sampleCount);
                 ++count) {
                System.out.println("Writing msg, count " + count);

                /* Modify the instance to be written here */
                //// Changes for Builtin_Topics
                instance.x = count;

                /* Write data */
                writer.write(instance, instance_handle);
                try {
                    Thread.sleep(sendPeriodMillis);
                } catch (InterruptedException ix) {
                    System.err.println("INTERRUPTED");
                    break;
                }
            }

            //writer.unregister_instance(instance, instance_handle);
        } catch (RETCODE_IMMUTABLE_POLICY immutable) {
            System.out.println("Cannot set factory Qos due to IMMUTABLE_POLICY"
                    + " for domain participant");
        } catch (RETCODE_INCONSISTENT_POLICY inconsistent) {
            System.out.println("Cannot set factory Qos due to "
                    + "INCONSISTENT_POLICY for domain participant");
        } finally {

            // --- Shutdown --- //

            if(participant != null) {
                participant.delete_contained_entities();

                DomainParticipantFactory.TheParticipantFactory.
                    delete_participant(participant);
            }
            /* RTI Data Distribution Service provides finalize_instance()
               method for people who want to release memory used by the
               participant factory singleton. Uncomment the following block of
               code for clean destruction of the participant factory
               singleton. */
            //DomainParticipantFactory.finalize_instance();
        }
    }
}
