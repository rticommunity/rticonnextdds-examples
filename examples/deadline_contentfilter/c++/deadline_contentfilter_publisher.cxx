/* deadline_contentfilter_publisher.cxx

   A publication of data of type deadline_contentfilter

   This file is derived from code automatically generated by the rtiddsgen 
   command:

   rtiddsgen -language C++ -example <arch> deadline_contentfilter.idl

   Example publication of type deadline_contentfilter automatically generated by 
   'rtiddsgen'. To test them follow these steps:

   (1) Compile this file and the example subscription.

   (2) Start the subscription on the same domain used for RTI Data Distribution
       with the command
       objs/<arch>/deadline_contentfilter_subscriber <domain_id> <sample_count>
                
   (3) Start the publication on the same domain used for RTI Data Distribution
       with the command
       objs/<arch>/deadline_contentfilter_publisher <domain_id> <sample_count>

   (4) [Optional] Specify the list of discovery initial peers and 
       multicast receive addresses via an environment variable or a file 
       (in the current working directory) called NDDS_DISCOVERY_PEERS. 
       
   You can run any number of publishers and subscribers programs, and can 
   add and remove them dynamically from the domain.

                                   
   Example:
        
       To run the example application on domain <domain_id>:
                          
       On Unix: 
       
       objs/<arch>/deadline_contentfilter_publisher <domain_id> o
       objs/<arch>/deadline_contentfilter_subscriber <domain_id> 
                            
       On Windows:
       
       objs\<arch>\deadline_contentfilter_publisher <domain_id>  
       objs\<arch>\deadline_contentfilter_subscriber <domain_id>    

       
modification history
------------ -------       
* Create and install listener for offered deadline missed status

* Set deadline QoS
*/

/* This example sets the deadline period to 1.5 seconds to trigger a deadline 
   if the DataWriter does not update often enough.  The writer's updates are 
   dependent on the application code, so the middleware can notify the 
   application that it has failed to update often enough.

*/
#include <stdio.h>
#include <stdlib.h>
#include "ndds/ndds_cpp.h"
#include "deadline_contentfilter.h"
#include "deadline_contentfilterSupport.h"


//// Start changes for Deadline
class deadline_contentfilterListener : public DDSDataWriterListener {
  public:
    virtual void on_offered_deadline_missed(
        DDSDataWriter* writer,
        const DDS_OfferedDeadlineMissedStatus& status) {

        deadline_contentfilter dummy;
        DDS_ReturnCode_t retcode =
            ((deadline_contentfilterDataWriter*) writer)->get_key_value(
                dummy, status.last_instance_handle);
    
        if (retcode != DDS_RETCODE_OK) {
            printf("get_key_value error %d\n", retcode);
            return;
        }
        
        printf("Offered deadline missed on instance code = %d\n", dummy.code);
    }
};

//// End changes for Deadline

/* Delete all entities */
static int publisher_shutdown(
    DDSDomainParticipant *participant)
{
    DDS_ReturnCode_t retcode;
    int status = 0;

    if (participant != NULL) {
        retcode = participant->delete_contained_entities();
        if (retcode != DDS_RETCODE_OK) {
            printf("delete_contained_entities error %d\n", retcode);
            status = -1;
        }

        retcode = DDSTheParticipantFactory->delete_participant(participant);
        if (retcode != DDS_RETCODE_OK) {
            printf("delete_participant error %d\n", retcode);
            status = -1;
        }
    }

    /* RTI Data Distribution Service provides finalize_instance() method for
       people who want to release memory used by the participant factory
       singleton. Uncomment the following block of code for clean destruction of
       the participant factory singleton. */
/*
    retcode = DDSDomainParticipantFactory::finalize_instance();
    if (retcode != DDS_RETCODE_OK) {
        printf("finalize_instance error %d\n", retcode);
        status = -1;
    }
*/

    return status;
}

extern "C" int publisher_main(int domainId, int sample_count)
{
    DDSDomainParticipant *participant = NULL;
    DDSPublisher *publisher = NULL;
    DDSTopic *topic = NULL;
    DDSDataWriter *writer = NULL;
    deadline_contentfilterDataWriter * deadline_contentfilter_writer = NULL;
    DDS_ReturnCode_t retcode;
    const char *type_name = NULL;
    int count = 0;  

    /* To customize participant QoS, use 
       DDSTheParticipantFactory->get_default_participant_qos() */
    participant = DDSTheParticipantFactory->create_participant(
        domainId, DDS_PARTICIPANT_QOS_DEFAULT, 
        NULL /* listener */, DDS_STATUS_MASK_NONE);
    if (participant == NULL) {
        printf("create_participant error\n");
        publisher_shutdown(participant);
        return -1;
    }

    /* To customize publisher QoS, use
       participant->get_default_publisher_qos() */
    publisher = participant->create_publisher(
        DDS_PUBLISHER_QOS_DEFAULT, NULL /* listener */, DDS_STATUS_MASK_NONE);
    if (publisher == NULL) {
        printf("create_participant error\n");
        publisher_shutdown(participant);
        return -1;
    }

    /* Register type before creating topic */
    type_name = deadline_contentfilterTypeSupport::get_type_name();
    retcode = deadline_contentfilterTypeSupport::register_type(
        participant, type_name);
    if (retcode != DDS_RETCODE_OK) {
        printf("register_type error %d\n", retcode);
        publisher_shutdown(participant);
        return -1;
    }

    /* To customize topic QoS, use
       participant->get_default_topic_qos() */
    topic = participant->create_topic(
        "Example deadline_contentfilter",
        type_name, DDS_TOPIC_QOS_DEFAULT, NULL /* listener */,
        DDS_STATUS_MASK_NONE);
    if (topic == NULL) {
        printf("create_topic error\n");
        publisher_shutdown(participant);
        return -1;
    }

    //// Start changes for Deadline
    // Create listener
    deadline_contentfilterListener* writer_listener = NULL;
    writer_listener = new deadline_contentfilterListener();
    if (writer_listener ==  NULL) {
        printf("listener instantiation error\n");
        publisher_shutdown(participant);
        return -1;
    }

    writer = publisher->create_datawriter(
        topic, DDS_DATAWRITER_QOS_DEFAULT, writer_listener,
        DDS_OFFERED_DEADLINE_MISSED_STATUS);
    if (writer == NULL) {
        printf("create_datawriter error\n");
        publisher_shutdown(participant);
        return -1;
    }

    /* If you want to change the DataWriter's QoS programmatically rather than
     * using the XML file, you will need to add the following lines to your
     * code and comment out the create_datawriter call above.
     *
     * In this case, we set the deadline period to 1.5 seconds to trigger
     * a deadline if the DataWriter does not update often enough.
     */
	/*
    DDS_DataWriterQos datawriter_qos;
    retcode = publisher->get_default_datawriter_qos(datawriter_qos);
    if (retcode != DDS_RETCODE_OK) {
        printf("get_default_datawriter_qos error\n");
        return -1;
    }

    // Set deadline QoS
    DDS_Duration_t deadline_period = {1, 500000000}; // 1.5sec
    datawriter_qos.deadline.period = deadline_period;

    writer = publisher->create_datawriter(
        topic, datawriter_qos, writer_listener,
        DDS_OFFERED_DEADLINE_MISSED_STATUS);
    if (writer == NULL) {
        printf("create_datawriter error\n");
        publisher_shutdown(participant);
        return -1;
    }
	*/

    //// End changes for Deadline

    deadline_contentfilter_writer = deadline_contentfilterDataWriter::narrow(writer);
    if (deadline_contentfilter_writer == NULL) {
        printf("DataWriter narrow error\n");
        publisher_shutdown(participant);
        return -1;
    }

    //// Start changes for Deadline
    // Create two instances for writing

    deadline_contentfilter *instance0 = NULL;
    deadline_contentfilter *instance1 = NULL;
    DDS_InstanceHandle_t handle0 = DDS_HANDLE_NIL;
    DDS_InstanceHandle_t handle1 = DDS_HANDLE_NIL;

    /* Create data samples for writing */
    instance0 = deadline_contentfilterTypeSupport::create_data();
    instance1 = deadline_contentfilterTypeSupport::create_data();
    if (instance0 == NULL || instance1 == NULL) {
        printf("deadline_contentfilterTypeSupport::create_data error\n");
        publisher_shutdown(participant);
        return -1;
    }

    // Set keys -- we specify 'code' as the key field in the .idl
    instance0->code = 0;
    instance1->code = 1;

    /* For data type that has key, if the same instance is going to be
       written multiple times, initialize the key here
       and register the keyed instance prior to writing */

    handle0 = deadline_contentfilter_writer->register_instance(*instance0);
    handle1 = deadline_contentfilter_writer->register_instance(*instance1);

    struct DDS_Duration_t send_period = {1, 0}; // 1sec

    instance0->x = instance0->y = instance1->x = instance1->y = 0;

    /* Main loop */
    for (count=0; (sample_count == 0) || (count < sample_count); ++count) {
        NDDSUtility::sleep(send_period);

        instance0->x++;
        instance0->y++;
        instance1->x++;
        instance1->y++;

        printf("Writing instance0, x = %d, y = %d\n", instance0->x, instance0->y);
        retcode = deadline_contentfilter_writer->write(*instance0, handle0);
        if (retcode != DDS_RETCODE_OK) {
            printf("write error %d\n", retcode);
            publisher_shutdown(participant);
            return -1;
        }

        if (count < 15) {
            printf("Writing instance1, x = %d, y = %d\n", instance1->x, instance1->y);
            retcode = deadline_contentfilter_writer->write(*instance1, handle1);
            if (retcode != DDS_RETCODE_OK) {
                printf("write error %d\n", retcode);
                publisher_shutdown(participant);
                return -1;
            }
        } else if (count == 15) {
            printf("Stopping writes to instance1\n");
        }
    }

    retcode = deadline_contentfilter_writer->unregister_instance(*instance0, handle0);
    if (retcode != DDS_RETCODE_OK) {
        printf("unregister instance error %d\n", retcode);
    }
    retcode = deadline_contentfilter_writer->unregister_instance(*instance1, handle1);
    if (retcode != DDS_RETCODE_OK) {
        printf("unregister instance error %d\n", retcode);
    }

    /* Delete data sample */
    retcode = deadline_contentfilterTypeSupport::delete_data(instance0);
    if (retcode != DDS_RETCODE_OK) {
        printf("deadline_contentfilterTypeSupport::delete_data error %d\n", retcode);
    }
    retcode = deadline_contentfilterTypeSupport::delete_data(instance1);
    if (retcode != DDS_RETCODE_OK) {
        printf("deadline_contentfilterTypeSupport::delete_data error %d\n", retcode);
    }

    //// End changes for Deadline

    /* Delete all entities */
    return publisher_shutdown(participant);
}

#if defined(RTI_WINCE)
int wmain(int argc, wchar_t** argv)
{
    int domainId = 0;
    int sample_count = 0; /* infinite loop */ 
    
    if (argc >= 2) {
        domainId = _wtoi(argv[1]);
    }
    if (argc >= 3) {
        sample_count = _wtoi(argv[2]);
    }

     /* Uncomment this to turn on additional logging
    NDDSConfigLogger::get_instance()->
        set_verbosity_by_category(NDDS_CONFIG_LOG_CATEGORY_API, 
                                  NDDS_CONFIG_LOG_VERBOSITY_STATUS_ALL);
    */
    
    return publisher_main(domainId, sample_count);
}
 
#elif !(defined(RTI_VXWORKS) && !defined(__RTP__)) && !defined(RTI_PSOS)
int main(int argc, char *argv[])
{
    int domainId = 0;
    int sample_count = 0; /* infinite loop */

    if (argc >= 2) {
        domainId = atoi(argv[1]);
    }
    if (argc >= 3) {
        sample_count = atoi(argv[2]);
    }

    /* Uncomment this to turn on additional logging
    NDDSConfigLogger::get_instance()->
        set_verbosity_by_category(NDDS_CONFIG_LOG_CATEGORY_API, 
                                  NDDS_CONFIG_LOG_VERBOSITY_STATUS_ALL);
    */
    
    return publisher_main(domainId, sample_count);
}
#endif
